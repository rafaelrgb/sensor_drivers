#include <time.h>

#include <ros/ros.h>
#include <sensor_msgs/Range.h>

#include <wiringSerial.h>

int main(int argc, char** argv){
  
  // Initialize ROS
  ros::init(argc, argv, "sonar_driver");

  // Declare the sonar publisher and inform the master that it will be publishing messages on topic "/sonar"
  ros::NodeHandle n;
  ros::Publisher sonar_pub = n.advertise<sensor_msgs::Range>("sonar", 50);

  // Use wiringPi to connect to the serial port
  int fd ;
  if ((fd = serialOpen ("/dev/ttyACM0", 9600)) < 0)
  {
    ROS_INFO( "Unable to open serial de);
    return 1 ;
  }

  // While the node is running, try to get data from the sensor
  while(n.ok()){

    // This call will block the program for 10 seconds until there is data to read
    char c = serialGetchar(fd);

    // Sensor sends data in the format of Rxxx, where each of the x is a number and the three numbers form the measure in inches
    // If a R character is read, the next three digits represent the measure
    if ( char == 'R' )
    {
      // Variable to store the data
      int value = 0;

      // Read the next 3 characters and store in the variable
      c = serialGetchar(fd);
      value += 100 * static_cast<int>( c );
      c = serialGetchar(fd);
      value += 10 * static_cast<int>( c );
      c = serialGetchar(fd);
      value += static_cast<int>( c );

      // Convert to meters
      value = value * 0.0254;

      // Get current time to fill the header of the message
      ros::Time scan_time = ros::Time::now();

      // Create and populate a Range message
      sensor_msgs::Range msg;
      msg.header.stamp = scan_time;
      msg.header.frame_id = "sonar_frame";
      msg.radiation_type = 0;
      msg.field_of_view = 0;
      msg.min_range = 0.15;
      msg.max_range = 6.45;
      msg.range = value;

      // Publish the message
      sonar_pub.publish(msg);

    }
  }
}
